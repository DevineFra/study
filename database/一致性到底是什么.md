# 一致性的理解
数据库系统中，一致性这个词在不同的环境下有着不同的含义：
* ACID中的Consistency
* 多版本一致性
* CAP理论中的一致性
* 多副本的一致性
* 一致性hash

这几个一致性的含义完全不是一回事。

## ACID中的Consistency
在单机数据库中，AID都属于数据库的特征，数据库本身要具备原子性、隔离性、持久性。然而C是依赖于AID的特性以及上层业务的设计来实现的。
举个例子，一致性代表着数据库的在进行了任何修改、任何时间都应该保证一个符合预定义规则的状态，这个预定义规则一般都是业务的规则，和
数据库本身无关。举个例子：我要求所有记录个人金额的值不能小于0，那么我可以通过设置字段的约束来保证，这样在事务的进行中如果出现违反
约束的情况则会返回失败。

## 多版本一致性
多版本并发控制技术是在并发事务场景下，解决读写冲突问题，并提供事务之间的隔离，提高并发读的性能。多版本意味着单份数据存储了多个版本，
我们要保证：
* 不读非本事务的未提交事务（脏读）
* 读取小于读取版本号的所有已提交数据（根据需求是否要保证事务内一致性的连续->不可重复度）
* 读写不互斥
在分布式场景下的多版本一致性维护更为复杂，除了要保证跨节点单事务的ACID，还要保证全局事务唯一、单调递增、全局一致性视图、2PC协调等。
  

## CAP中的Consistency
CAP是在分布式场景下，一个系统只能同时满足Consistency、Availablity、Partition Tolerance三种特性中的两个。那么这里的一致性
可能对于大部分人来讲更好理解，他代表的是所有节点对于同一数据的读取操作都应该返回最新的、一致的值。

## 多副本的一致性
多副本的一致性和CAP的一致性有相似之处，但并不完全相同。  
在CAP中，更多强调的是强一致或线性一致，他代表这在分布式场景下所有的数据读写操作也要在业务看来是在单节点下执行的，这样意味着顺序
性、即时可见性、外部一致性。  
而多副本这是另一回事，我们可以在分布式系统中讨论多副本也可以在单机场景下讨论多副本。他实际是为了提高可用性和扩展性，通过复制的方式
来分发数据，在这种场景下副本之间的数据一致性就成了一个关键问题,常见的模型包括：
* 最终一致性：所有副本最终会达到一致状态，但不保证具体的时间
* 会话一致性：在一个会话期间，用户看到的数据是强一致的，但是不同会话会暂时看到不一致的数据。
* 强一致性：和CAP理论中的一致性类似，要求保证全局的强一致性视图

## 一致性HASH
在分布式场景下，一致性hash这是对于传统hash算法的优化，保证对于某个数据和节点的映射关系在进行横向扩展的场景下尽量保证不变，来应对
高效的数据分配和负载均衡，提高系统的稳定性。

# 不同数据库场景下如何实现一致性读
## MySQL
MVCC，锁等，这里主要讲一下读视图。
### 当前读
### 快照读
生成一个快照的时候会生成三个全局属性
1. trx_list 一个数值列表，用来维护RV生成时刻此时系统正活跃的事务ID
2. up_limit_id 记录trx_list中的最小的事务ID 
3. low_limit_id  RV生成时刻系统尚未分配的下一个事务ID，即目前(不一定是RV中)已经出现过的事务ID最大值+1
后面读取数据的时候开始进行比较
1. 首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
2. 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
3. 判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的

## OCEANBASE
### 多版本一致性读
事务表
![image](https://github.com/user-attachments/assets/781efb38-3bee-4391-bed5-36e064c90fe3)

事务表是一个内存表，代表本副本中正在执行中的事务集合，事务在执行过程中会根据不同的事务状态，来决定是否要读取到对应的数据。其中数据状态包含提交（COMMIT）、执行（RUNNING）、回滚（ABORT）。对于执行（RUNNING）的事务，可能存在 本地提交版本号（local commit version，即 prepare version）；对于提交的事务, 存在 全局提交版本号（global commit version，即 commit version）。其中 全局提交版本号 代表事务最终的版本，也是我们一致性位点的决定因素。
如上图右所示，事务 6 处于回滚状态；事务 7 处于提交状态，全局提交版本号 为 80；事务 12 处于执行状态，不存在 本地提交版本号；事务 15 处于执行状态，本地提交版本号 为 130。

读请求处理
![image](https://github.com/user-attachments/assets/d82edb3b-c246-484b-bf7b-ed0286c46cb0)

接下来我们分开来分析，当读取到提交或回滚的事务时，可以根据 全局提交时间戳 和状态比较简单地推测出是否需要读到对应数据。如下图所示，读取请求 r1 以 90 作为读版本号进行读取，根据快照读的策略，会选择版本号为 80，数据为 b 的数据进行读取。
当读取到 RUNNING 状态的事务时，可以安全地跳过这个数据。如下图所示，读取请求 r2 以 130 作为读版本号进行读取，可以安全跳过未进入两阶段提交的事务 12 读取到版本号为 100，数据为 b 的数据。
当读取到 PREPARE 状态的事务时，无法确定事务是否会提交, 因此会等在这行的事务上。如下图所示，读取请求 r3 以 140 作为读版本号进行读取，等待两阶段提交状态且本地提交时间戳为 130 的事务最后决定 全局提交时间戳 和读时间戳 140 的关系。



## PolarDB-X
