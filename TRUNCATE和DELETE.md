# DELETE
## 操作原理
DELETE是DML语句，只删除数据不删除表的结构，会走事务，所以执行的时候可以触发trigger

MySQL的Innodb中，实际给删除的数据打了个标记为已删除，所以表文件在磁盘占用的空间不会变小，但是新增数据是可以覆盖这部分空间的。

delete from table_name删除表的全部数据,对于MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;对于delete from table_name where xxx 带条件的删除, 不管是InnoDB还是MyISAM都不会释放磁盘空间;
### 加锁情况
行级锁：默认情况下，InnoDB使用行级锁来执行DELETE操作。这意味着它只会锁定将要被删除的行，而不是整个表。这有助于减少锁的争用，提高并发性。

Next-Key Locks：在可重复读（Repeatable Read）隔离级别下，为了防止幻读（Phantom Reads），InnoDB不仅会对要删除的行加锁，还会对索引记录之间的“间隙”加锁，这就是所谓的Next-Key Lock。这包括记录上的锁（Record Lock）和间隙锁（Gap Lock）的组合，确保在事务期间，不会有新的记录插入到被锁定的范围内。

意向锁（Intention Locks）：当DELETE操作需要加行锁时，InnoDB还会自动加上一个意向锁（INTENTION LOCK），表明即将在更低级别的粒度上加锁。意向锁分为两种：意向共享锁（IS）和意向排他锁（IX）。意向锁不会阻止其他事务访问表，但它们提供了一种信号，表明某个事务可能即将在这个表中的某个行上加锁。

表级锁：在MyISAM存储引擎中，由于不支持行级锁，DELETE 操作会加表级锁，这会锁定整个表，阻止其他任何事务同时对表进行读写操作，直到当前事务结束。

锁的持续时间：DELETE 操作加的锁一般会在事务提交或回滚后释放。如果使用了显式的锁定语句（如SELECT ... FOR UPDATE），那么锁会按照该语句的规则来管理。

### 对select count(*)的影响

* 索引和数据碎片化：当执行 DELETE 操作后，表中的数据会产生空洞，尤其是在InnoDB存储引擎中，已删除的行会被标记为已删除，但实际空间并不会立即回收，这可能导致索引和数据文件的碎片化。碎片化会降低数据读取效率，从而影响 COUNT(*) 查询速度。

* MVCC（多版本并发控制）：InnoDB 引擎使用MVCC来支持事务隔离级别，已删除的行在事务未提交前仍可见，这会增加 COUNT(*) 扫描的行数。虽然 COUNT(*) 在InnoDB中通常只计算未被标记为删除的行，但如果表上有活跃的事务正在查看旧版本的数据，这仍然可能影响性能。

* 锁竞争：在高并发环境下，如果 DELETE 操作与后续的 SELECT COUNT(*) 同时发生，可能会引起锁的竞争。特别是当 DELETE 操作持有行锁或间隙锁时，可能会阻塞或延迟其他读取操作。

* 统计信息未更新：MySQL依赖于统计信息来优化查询计划，DELETE 大量数据后，表的统计信息可能不再准确，这可能导致优化器做出不理想的执行计划，影响 COUNT(*) 的性能。

* 事务日志膨胀：大量删除操作会增加重做日志和undo日志的大小，影响整体I/O性能，间接影响后续查询。

# TRUNCATE
属于数据库DDL定义语言，不走事务，原数据不放到 rollback segment 中，操作不触发 trigger。执行后立即生效，无法找回 执行后立即生效，无法找回 执行后立即生效，无法找回。truncate table其实有点类似于drop table 然后creat,
只不过这个create table 的过程做了优化，比如表结构文件之前已经有了等等。所以速度上应该是接近drop table的速度。

# DROP
属于数据库DDL定义语言，同Truncate；执行后立即生效，无法找回 执行后立即生效，无法找回 执行后立即生效，无法找回。
* drop table table_name 立刻释放磁盘空间，不管是 InnoDB 和 MyISAM;
* drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index);
* 依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。
